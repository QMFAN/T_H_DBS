## 问题定位
- Redis 实现的方法返回 Promise，与接口 `AnomalyStore` 的同步签名不匹配，导致 TS 编译错误（截图所示 getOverview/resolveOne/bulkResolve/pendingCountForTask/totalPending）。
- Redis 存储的 `findById` 为占位返回 `null`，后续调用可能需要具体实现。

## 解决方案
- 将 `AnomalyStore` 接口统一改为异步签名（全部返回 Promise），以适配 ioredis 异步行为：
  - `getOverview(): Promise<ImportAnomalyOverviewDto>`
  - `findById(anomalyId: string): Promise<... | null>`
  - `resolveOne(...): Promise<AnomalyStoreItemResult | null>`
  - `bulkResolve(...): Promise<Array<AnomalyStoreItemResult & { anomalyId: string }>>`
  - `pendingCountForTask(taskId: number): Promise<number>`
  - `totalPending(): Promise<number>`
- 内存实现同步改造为异步兼容（返回 `Promise.resolve(...)`），保持行为不变（backend/src/excel-import/anomaly-store.memory.ts）。
- Redis 实现完善 `findById`：读取键并解析为对象（backend/src/excel-import/anomaly-store.redis.ts）。
- ExcelImportService 使用 `await` 调用临时存储方法（已部分使用 Promise.resolve），统一改为 `await`，清理多余的 `Promise.resolve`（backend/src/excel-import/excel-import.service.ts）。

## 验证步骤
1. 修改接口与实现，确保两种存储实现均通过编译。
2. 运行单测：`npm test -s`（backend），保证现有用例通过。
3. 启动后端：`npm run start:dev`，确认编译通过无 TS 错误。
4. 端到端冒烟：
   - 上传样例 Excel → `GET /api/imports/conflicts` 返回临时冲突；
   - 批量处置重复/单条处置冲突 → `pendingConflicts` 归零；
   - MySQL 采样验证数据落库正确。

## 风险与回滚
- 如 Redis 未就绪，切环境变量为 `IMPORT_ANOMALY_STORE=memory` 启动验证；确保两种实现均可运行。
- 如编译仍有类型报错，回溯方法签名与调用处，确保 `await` 与返回类型一致。